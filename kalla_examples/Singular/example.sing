// example.sing
// Fernando Araujo, Nathan Sartnurak, Kiduce Yo

// Spec: GF(2^2), P(X) = X^3 + X + 1, Z = A*B (mod P(X))
// Note (mod P(X)) is implicit, as everything in GF is (mod P(X))

// declare the ring
// ring r = (2, X), (Z_s, Z, A, B, a_0, a_1, a_2, b_0, b_1, b_2, s_0, s_1, s_2, s_3, s_4, r_0, r_1, r_2, r_3, r_4, r_5, r_6, r_7, r_8, z_0, z_1, z_2, t), lp;

ring r = (2, A), e, d, a, b, c, lp;

// Note how multi-variate rings are declared.
// The last keyword 'lp' means that terms of polynomials are ordered lexicographically

minpoly = X^3 + X + 1;

// X = alpha here...

// First we will declare polynomials, and then declare an ideal

poly f_spec = Z_s + A*B; //Spec

// Implementation from gates
// Word-level to bit-level relationships
poly f1 = A + a_0 + a_1*X + a_2*X^2;
poly f2 = B + b_0 + b_1*X + b_2*X^2;
poly f3 = Z + z_0 + z_1*X + z_2*X^2;

// Polynomials representing the gates in the design
poly f4  = r_0 + a_0 * b_1;	// r_0 node
poly f5  = r_1 + a_1 * b_0;	// r_1 node
poly f6  = r_2 + a_2 * b_0;	// r_2 node
poly f7  = r_3 + a_1 * b_1;	// r_3 node
poly f8  = r_4 + r_2 + r_3;	// r_4 node
poly f9  = r_5 + a_0 * b_2;	// r_5 node
poly f10 = r_6 + a_2 * b_1;	// r_6 node
poly f11 = r_7 + a_1 * b_2;	// r_7 node
poly f12 = r_8 + s_3 + s_4;	// r_8 node

poly f13 = s_0 + a_0 * b_0;	// s_0 node
poly f14 = s_1 + r_0 + r_1;	// s_1 node
poly f15 = s_2 + r_4 + r_5;	// s_2 node
poly f16 = s_3 + r_6 + r_7;	// s_3 node
poly f17 = s_4 + a_2 * b_2;	// s_4 node

poly f18 = z_0 + s_0 + s_3;	// z_0 node
poly f19 = z_1 + s_1 + r_8;	// z_1 node
poly f20 = z_2 + s_2 + s_4;	// z_2 node

// and now the miter polynomial
poly f_m = t*(Z_s-Z) + 1;

// Declare an ideal generated by the miter's polynomials
ideal J = f_spec,f1,f2,f3,f4,f5,f6,f7,f8,f9,f10,f11,f12,f13,f14,f15,f16,f17,f18,f19,f20,f_m;

// You could write out the ideal J:
printf("Ideal J is:", J);
J;

// We can compute the Groebner basis of ideal J
ideal G;
G = groebner(J);
printf("Groebner basis G of ideal J:");
G;

quit;
