/*
ORgates.sing
Fernando Araujo, Nathan Sartnurak, Kidus Yohannes

Run on Singular:
<"ORgates.sing";
*/

// This is how you declare a ring
// This is r = Q[d, c, b, a] with LEX d>c>b>a
// Outputs z, y, and x go before PIs: LEX z>y>x>d>c>b>a
ring r = 2, (z, y, x, d, c, b, a), lp; 

// Uncomment this ring declaration for more experiments
// lp = LEX, dp = DEGREVLEX, Dp = deglex

// Chain of OR gates
// poly f = d + c + b + a;

poly g(1) = z + y*d + y + d;
poly g(2) = y + x*c + x + c;
poly g(3) = x + a*b + a + b;

printf("g1: %s", g(1));
printf("g2: %s", g(2));
printf("g3: %s", g(3));

printf("");

// This is ideal J = <f, g, h> generated by polynomials f, g, h
ideal J = g(1), g(2), g(3);

poly h(1) = 0;
poly h(2) = 0;
poly h(3) = 0;
poly h(4) = 0;
poly h(5) = 0;
poly h(6) = 0;
poly h(7) = 0;

poly func = z;

// Classical reduction Algorithm
// /*
printf("Classical Reduction Algorithm");
 
for (int i = 1; i < 8; i++)
{
   for (int j = 1; j < size(J) + 1; j++)
   {
      // This a 1-step reduction (1 step of division)
      if (lead(func)/lead(J[j]) != 0)
      {
	 printf("-------------------------------");
	 printf("i = %s",i);
         printf("j = %s",j);
         printf("u(%s) = %s", i, (lead(func)/lead(J[j])));
         printf("f = %s",func);
	 printf("");

	 printf("%s --g(%s)--> h(%s)", func, j, i);
         //h(i) = func - (lead(func)/lead(g(j)))*g(j);
         h(i) = func - (lead(func)/lead(J[j]))*J[j];

         func = h(i);
         printf("h(%s) = %s", i, h(i));

         printf("");

	 // This is how you print a value
	 printf("Leading Coefficient of h(%s):", i);
	 leadcoef(h(i));
	 printf("Leading Monomial of h(%s):", i);
	 leadmonom(h(i));

         printf("");
	 break;
      }
   }
}
// */


/* Improved Reduction with one-step

rj = ri + q*fj
index j = 1 + i

ri = xj*[then(ri)] + [else(ri)]
fj = xj + [else(fj)]
xj = top variable of ri and fj
q  = (then(ri))
*/

// call functions
//poly J[1] = g(1) = z + y*d + y + d;
//poly J[2] = g(2) = y + x*c + x + c;
//poly J[3] = g(3) = x + a*b + a + b;

// remainders
poly r(1) = 0;
poly r(2) = 0;
poly r(3) = 0;

// variables
poly then_r = 0;
poly else_r = 0;
poly else_f = 0;
poly xj     = 0;
poly q      = 0;
poly ri     = 0;
poly fj     = 0;

// beginning reduction function 
poly func = z;
printf("");

// /* 
printf("1-step Improved reduction Algorithm");
printf("-------------------------------");

for (int i = 1; i < size(J) + 1; i++)
{
   if (lead(func)/lead(J[i]) != 0)
   {
      xj     = lead(J[i]);

      else_r = subst(func, xj, 0);
      then_r = func - else_r;
      then_r = subst(then_r, xj, 1);

      else_f = subst(J[i], xj, 0);

      ri     = xj*then_r + else_r;
      fj     = xj + else_f;
      q      = then_r;

      r(i)   = ri + q*fj;
      printf("r(%s) = %s", i, r(i));

      // recall remainder for next operation
      func = r(i);
   }
} // */


printf("");


// Compute a Grobner Basis
// two algorithms implemented in singular to compute GB
J = groebner(J);
J = slimgb(J);

// print the GB
printf("GB of Ideal J");
J;
printf("");

// Divide f by the groebner basis of ideal J
poly l = reduce(z, J);
// print poly l;
printf("Reduction of z, J");
l;

// l has to be 0 as f is already in J

quit;
