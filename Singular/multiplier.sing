/*
multiplier.sing
Fernando Araujo, Nathan Sartnurak, Kidus Yohannes

Run on Singular:
<"multiplier.sing";
*/

// This is how you declare a ring
// This is r = Q[d, c, b, a] with LEX d>c>b>a
// Outputs z, y, and x go before PIs: LEX z>y>x>d>c>b>a
ring r = 2, (z1, z0, r0, c0, c3, c1, c2, a0, a1, b0, b1), lp; 

// Uncomment this ring declaration for more experiments
// lp = LEX, dp = DEGREVLEX, Dp = deglex

// 2-bit multiplier
// poly z1 = a0*b1 + a1+b0 + a1*b1;
// poly z0 = a0*b0 + a1*b1;

poly g(1) = c0 + a0*b0;
poly g(2) = c1 + a0*b1;
poly g(3) = c2 + a1*b0;
poly g(4) = c3 + a1*b1;
poly g(5) = r0 + c1 + c2;
poly g(6) = z0 + c0 + c3;
poly g(7) = z1 + r0 + c3;

printf("g1: %s", g(1));
printf("g2: %s", g(2));
printf("g3: %s", g(3));
printf("g4: %s", g(4));
printf("g5: %s", g(5));
printf("g6: %s", g(6));
printf("g7: %s", g(7));

printf("");

// This is ideal J = <f, g, h> generated by polynomials f, g, h
ideal J = g(7), g(6), g(5), g(1), g(4), g(2), g(3);

poly h(1)  = 0;
poly h(2)  = 0;
poly h(3)  = 0;
poly h(4)  = 0;
poly h(5)  = 0;
poly h(6)  = 0;

//poly func = z1;
poly func = z0;

// Classical reduction Algorithm
// /*
printf("Classical Reduction Algorithm");
 
for (int i = 1; i < 6; i++)
{
   for (int j = 1; j < size(J) + 1; j++)
   {
      // This a 1-step reduction (1 step of division)
      if (lead(func)/lead(J[j]) != 0)
      {
	 printf("-------------------------------");
	 printf("i = %s",i);
         printf("j = %s",j);
         printf("u(%s) = %s", i, (lead(func)/lead(J[j])));
         printf("f = %s",func);
	 printf("");

	 printf("%s --g(%s)--> h(%s)", func, j, i);
         h(i) = func - (lead(func)/lead(J[j]))*J[j];

         func = h(i);
         printf("h(%s) = %s", i, h(i));

         printf("");

	 // This is how you print a value
	 printf("Leading Coefficient of h(%s):", i);
	 leadcoef(h(i));
	 printf("Leading Monomial of h(%s):", i);
	 leadmonom(h(i));

         printf("");
	 break;
      }
   }
}
// */


/* Improved Reduction with one-step

rj = ri + q*fj
index j = 1 + i

ri = xj*[then(ri)] + [else(ri)]
fj = xj + [else(fj)]
xj = top variable of ri and fj
q  = (then(ri))
*/

// call functions
//poly J[1] = g(7)
//poly J[2] = g(6)
//poly J[3] = g(5)
//poly J[4] = g(1)
//poly J[5] = g(4)
//poly J[6] = g(2)
//poly J[7] = g(3)

// remainders
poly r(1) = 0;
poly r(2) = 0;
poly r(3) = 0;
poly r(4) = 0;
poly r(5) = 0;
poly r(6) = 0;
poly r(7) = 0;

// variables
poly then_r = 0;
poly else_r = 0;
poly else_f = 0;
poly xj     = 0;
poly q      = 0;
poly ri     = 0;
poly fj     = 0;

// beginning reduction function 
//poly func = z1;
//poly func = z0;
ideal xi = z0, z1;
printf("");

// /* 
printf("1-step Improved reduction Algorithm");
printf("-------------------------------");

for (int k = 1; k < size(xi) + 1; k++)
{
   poly func = xi[k];
   printf("xi = %s", func);
   printf("");

   for (int i = 1; i < size(J) + 1; i++)
   {
      if (lead(func)/lead(J[i]) != 0)
      {
         xj     = lead(J[i]);

         else_r = subst(func, xj, 0);
         then_r = func - else_r;
         then_r = subst(then_r, xj, 1);

         else_f = subst(J[i], xj, 0);

         ri     = xj*then_r + else_r;
         fj     = xj + else_f;
         q      = then_r;

         r(i)   = ri + q*fj;
         printf("r(%s) = %s", i, r(i));

         // recall remainder for next operation
         func = r(i);
      }
   }
   printf(""); 
} // */


printf("");


// Compute a Grobner Basis
// two algorithms implemented in singular to compute GB
J = groebner(J);
J = slimgb(J);

// print the GB
printf("GB of Ideal J");
J;
printf("");

// Divide f by the groebner basis of ideal J
poly l1 = reduce(z1, J);
printf("Reduction of z1, J");
l1;
printf("");

poly l0 = reduce(z0, J);
printf("Reduction of z0, J");
l0;
printf("");

// l has to be 0 as f is already in J

quit;
